/*
 * Copyright 2013 Keith D Swenson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Contributors Include: Shamim Quader, Sameer Pradhan, Kumar Raja, Jim Farris,
 * Sandia Yang, CY Chen, Rajiv Onat, Neal Wang, Dennis Tam, Shikha Srivastava,
 * Anamika Chaudhari, Ajay Kakkar, Rajeev Rastogi
 */

package org.socialbiz.cog;


import java.io.Reader;
import java.io.StringReader;

import javax.swing.text.MutableAttributeSet;
import javax.swing.text.html.HTML;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.parser.ParserDelegator;

/**
 * This is a object that takes a HTML value generated by WYSIWYG Editor and
 * generate the Wiki text according to the {@link WikiConverter}. Not sure
 * whether this covers everything. but it handles content that is copy paste
 * from the other resources as well for example outlook etc.
 *
 * NOTE: in March 2012 there was a change to the wiki format by adding the
 * ability to "escape" certain characters with a escape character (EC).  Prior to this,
 * if anyone typed a left square bracket, two underscores, two single quotes,
 * and sometimes other characters into the HTML editor, those would disappear
 * because those are the character sequences in the underlying wiki format
 * that cause styles to appear.  Inventing an escape mechanism means that
 * when those characters are encountered converting from HTML, an additional
 * EC will be added before the character.  Upon output, when
 * a EC is encountered in the wiki text followed by one of these
 * characters, the EC will be suppressed, and the following character will
 * appear without being interpreted as a styling character.  If a EC
 * character appears in the HTML input it will also need a preceeding an EC
 * so that it is not confused with being used to escape the following char.
 *
 * The EC is never seen by the user except when they edit using RAW wiki text.
 * So it does not matter what the EC character looks like.
 * RAW edit is still a possibility sometime, but typically a person who is
 * editing the raw text will put up with some special characters.
 * Because we already have a large body of wiki text to preserve, we would
 * like to pick a character that is not very commonly used, in order to reduce
 * the amount of conversion problems.  We would like to do conversion on the
 * fly so that there is no need to process the entire existing knowledge base.
 * As each note is edited, the new version will be saved with the escapes.
 *
 * EC will be บ (masculine ordinal indicator) because this is quite uncommonly
 * used, and almost certainly is not used in any of our existing documentation.
 *
 *     WIKI FORMAT         HTML
 *        บ_                 _
 *        บ'                 '
 *        บ[                 [
 *        บบ                 บ
 *
 * If the EC is seen in the wiki format followed by anything else, it is
 * technically an error (not allowed) but will be handled by simply outputting
 * the exact same sequence and NOT suppressing the EC:
 *
 *        บ?                บ?
 *
 * MIGRATION: because we have a lot of wiki-format information that does
 * not have the EC escapes, how is this migrated?
 * First of all, use of underscore, square bracket, and single quote were
 * ONLY allowed for formatting purposes.  The simply was no way to put a
 * square bracket in and not have it interpreted as a link.  Wiki format
 * simply did not support this so we should not expect a lot of this to exist.
 *
 * The biggest issue is for previous usage of the EC character.  A single
 * EC could have been in the text before, not for the purpose of escaping
 * the following character.  If the following character is not one of the
 * four characters that can be escaped, then it will be output exactly as
 * it had in the past.  If that is to the editor, and the user updates
 * then the EC will be escaped when it is input back to the system, and the
 * topic will be effectively converted.
 *
 * The only really undesirable situation occurs when the EC exists in a
 * topic already followed by an underscore, single quote, square bracket,
 * or another EC.  In that situation, the output will be distorted from what
 * it used to be.  We are hoping that the combination of using an
 * unusual EC, along with the unlikelyhood that it is followed by on of the
 * four special characters, we expect this to have minimal effect.
 * Any cases that might exist will have to be converted by hand, normally
 * by adding the EC back in (which had been suppressed) and re-styling
 * the following text to the way it had been.
 *
 * Once enough time has passed for the topics to be considered converted
 * it will be relatively safe to add new characters that can be escaped
 * for future special meanings.
 */
public class HtmlToWikiConverter {

    //public static String baseURL = null;
    /**
     * This method takes a HTML String generated by the Editor and will use
     * {@link HTMLParser} to parse the HTML to generate WIKI text from that.
     *
     * @param htmlValue
     * @return
     * @throws Exception
     */
    public static String htmlToWiki(String unused,String htmlValue) throws Exception {
        //HtmlToWikiConverter.baseURL = baseURL;
        // There was some problem saving &nbsp; in XML file so replaced it with
        // the space.
        htmlValue = htmlValue.replaceAll( "&nbsp;", " " ).replaceAll( "\r", "" );

        Reader reader = new StringReader( htmlValue );
        HTMLEditorKit.Parser parser = new ParserDelegator();
        HTMLParser htmlParser = new HTMLParser();
        parser.parse( reader, htmlParser, true );
        reader.close();
        String wikiValue = htmlParser.wikiText.toString();
        wikiValue= wikiValue.trim();
        return wikiValue;
    }

}

/**
 * This class is subclass of {@link HTMLEditorKit.ParserCallback}. This class
 * implemented method to parse HTML and convert WIKI text from that.
 *
 */
class HTMLParser extends HTMLEditorKit.ParserCallback {

    private String href = "";
    private StringBuilder linkText = null;
    private boolean isHREF = false;

    private int BULLETS_INDENTATION_LEVEL = 0;
    private boolean isBold      = false;
    private boolean isItalics   = false;
    private String  inBlock     = null;

    //these are set instead of outputting a style prefix
    //and they actually cause the output when the first non-whitespace
    //text is output
    private boolean prepareBold = false;
    private boolean prepareItal = false;
    private boolean prepareLineFeed = false;

    //TODO: convert this to use a stream instead if a string buffer
    StringBuilder wikiText = new StringBuilder();

    public void handleText(char[] data, int pos)
    {

        String tempStr = new String(data);
        tempStr = tempStr.trim();
        if (tempStr.length()==0)
        {
            return;   //don't do any processing below because not non-white
        }

        //none of these should be output unless the is non-empty text
        if (inBlock==null)
        {
            //outputting text without any block should cause a paragraph block to start
            startBlock("\n");
        }
        if (prepareLineFeed)
        {
            wikiText.append("\n:");
            prepareLineFeed = false;
        }
        if (prepareBold)
        {
            wikiText.append("__");
            prepareBold = false;
            isBold = true;
        }
        if (prepareItal)
        {
            wikiText.append("''");
            prepareItal = false;
            isItalics = true;
        }
        if (isHREF)
        {
            //if you are inside a link, then append the text to this
            linkText.append(data);
        }
        else {
            //this text is NOT in a link.  We need to escape dangerous
            //characters, and also to look for unlinked URLS for automatic
            //conversion to a link.
            StringBuilder smallerBuffer = new StringBuilder();

            //copy over -- don't escape here, do it lower down
            for (char ch : data) {
                smallerBuffer.append( ch );
            }

            //now search for occurrences of http:// and https://
            int start = 0;
            while (start<smallerBuffer.length()) {
                int pos1 = smallerBuffer.indexOf("http://", start);
                int pos2 = smallerBuffer.indexOf("https://", start);
                if (pos1<start && pos2<start) {
                    //nothing else found, so copy the rest of the string and quit
                    copyWhileEscaping(wikiText, smallerBuffer.substring(start));
                    start = smallerBuffer.length();
                    break;
                }

                //figure out whether http or https is earlier
                if ((pos2>=start && pos2<pos1) || pos1<start) {
                    pos1 = pos2;
                }
                //find the end of the link by a space character.
                int endPos = smallerBuffer.indexOf(" ", pos1);
                if (endPos<pos1) {
                    endPos = smallerBuffer.length();
                }

                //now copy the link inside of square brackets
                copyWhileEscaping(wikiText, smallerBuffer.substring(start, pos1));
                wikiText.append("[");
                wikiText.append(smallerBuffer.substring(pos1, endPos));
                wikiText.append("]");
                start = endPos;
            }
        }
    }

    private void copyWhileEscaping(StringBuilder dest, String input) {
        //walk through and escape special characters that would
        //otherwise cause possible styling errors
        for (int i=0; i<input.length(); i++) {
            char ch = input.charAt(i);
            if (ch=='[' || ch=='_' || ch=='\'' || ch=='บ') {
                dest.append('บ');
            }
            dest.append( ch );
        }
    }

    //text block is H1, H2, H3, P
    private void startBlock(String blockType)
    {
        if (inBlock != null)
        {
            //this is a clean up situation ... a block was started without concluding another
            //block, this could happen if it put one block inside another block
            //this code will terminate the outer block, and start a new block for the inner.
            concludeBlock();
        }
        inBlock = blockType;
        if ("*".equals(blockType))
        {
            for (int i = 0; i < BULLETS_INDENTATION_LEVEL; i++)
            {
                wikiText.append( "*" );
            }
            wikiText.append( " " );
        }
        else
        {
            wikiText.append(blockType);
        }
    }

    private void concludeBlock()
    {
        if (isItalics)
        {
            wikiText.append("''");
        }
        if (isBold)
        {
            wikiText.append("__");
        }
        if (inBlock != null)
        {
            wikiText.append("\n");
        }
        inBlock = null;
        prepareBold = false;
        isBold = false;
        prepareItal = false;
        isItalics = false;
        prepareLineFeed = false;
    }


    public void handleStartTag(HTML.Tag t, MutableAttributeSet a, int pos) {
        if (isHREF)
        {
            //when we are inside a hyperlink, ALL tags are ignored
            return;
        }
        if (t == HTML.Tag.H1)
        {
            startBlock("!!!" );
        }
        else if (t == HTML.Tag.H2)
        {
            startBlock("!!" );
        }
        else if (t == HTML.Tag.H3)
        {
            startBlock("!" );
        }
        else if (t == HTML.Tag.P)
        {
            startBlock("\n");
        }
        else if (t == HTML.Tag.PRE)
        {
            startBlock("{{{\n");
        }
        else if (t == HTML.Tag.LI)
        {
            startBlock("*");
        }
        else if (t == HTML.Tag.UL)
        {
            concludeBlock();
            BULLETS_INDENTATION_LEVEL++;
        }
        else if (t == HTML.Tag.A)
        {
            Object o = a.getAttribute( HTML.Attribute.HREF );
            if (o!=null) {
                href = o.toString().trim();
            }
            else {
                href= "";
            }

            isHREF = true;
            linkText = new StringBuilder();
        }
        else if (t == HTML.Tag.B || t == HTML.Tag.STRONG)
        {
            prepareBold = true;
        }
        else if (t == HTML.Tag.I || t == HTML.Tag.EM)
        {
            prepareItal = true;
        }
        else if (t == HTML.Tag.SPAN)
        {
            //apparently the text editor we are using will inclue span tags for
            //certain kinds of styling, so need to respond.  Difficult, however
            //to match the right end tag when there are multiple nested spans.
            //Might consider tracking each span as nested in.
            String clazz = "";
            if (a.getAttribute( HTML.Attribute.STYLE ) != null)
            {
                clazz = a.getAttribute( HTML.Attribute.STYLE ).toString();
            }
            if (clazz.contains( "bold;" ) && !isBold)
            {
                prepareBold = true;
            }
            if (clazz.contains( "italic;" ) && !isItalics)
            {
                prepareItal = true;
            }

        }
        else if (t == HTML.Tag.DIV) {
            //some cases have DIV tags only, and we need to treat them like 
            //paragraphs.
            startBlock("\n");
        }
        else if (t == HTML.Tag.TD || t == HTML.Tag.TH) {
            //if you are in a table, then we should treat the cells in the table as creating
            //new paragraph blocks.
            startBlock("\n");
        }
    }

    public void handleEndTag(HTML.Tag t, int pos) {
        if (t == HTML.Tag.A)
        {
            String lText = linkText.toString().trim();
            if (lText.length()>0) {
                wikiText.append("[");
                wikiText.append(lText);
                if (href!=null && href.length()>0)  {
                    wikiText.append("|");
                    wikiText.append(href);
                }
                wikiText.append("]");
            }
            isHREF = false;
            linkText = null;
            href=null;
        }
        else if (isHREF)
        {
            //when we are inside a hyperlink, ALL tags are ignored (except the end of hyperlink)
            return;
        }
        else if (t == HTML.Tag.H1 || t == HTML.Tag.H2
            || t == HTML.Tag.H3 || t == HTML.Tag.P || t == HTML.Tag.DIV
            || t == HTML.Tag.TD || t == HTML.Tag.TH )
        {
            concludeBlock();
        }
        else if (t == HTML.Tag.PRE)
        {
            concludeBlock();
            wikiText.append("\n}}}" );
        }
        else if (t == HTML.Tag.UL)
        {
            concludeBlock();
            BULLETS_INDENTATION_LEVEL--;
        }
        else if (t == HTML.Tag.LI)
        {
            concludeBlock();
        }
        else if (t == HTML.Tag.B || t == HTML.Tag.STRONG)
        {
            if (isBold)
            {
                wikiText.append("__");
            }
            isBold = false;
            prepareBold = false;
        }
        else if (t == HTML.Tag.I || t == HTML.Tag.EM)
        {
            if (isItalics)
            {
                wikiText.append("''");
            }
            isItalics = false;
            prepareItal = false;
        }
        else if (t == HTML.Tag.SPAN)
        {
            /**
             * This will basically handle the span tag. The WYSIWYG editor
             * generate span tag for bold and italic text closing span tag will
             * be replaced accordingly.
             *
             */
            if (isItalics)
            {
                wikiText.append( "''" );
                isItalics = false;
            }
            prepareItal = false;
            if (isBold)
            {
                wikiText.append( "__" );
                isBold = false;
            }
            prepareBold = false;
        }
    }

    public void handleSimpleTag(HTML.Tag t, MutableAttributeSet a, int pos) {
        if (t == HTML.Tag.BR)
        {
            prepareLineFeed = true;
        }
        else if (t == HTML.Tag.HR)
        {
            wikiText.append( "\n----\n" );
        }
    }

}
